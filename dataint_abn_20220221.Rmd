---
title: "SCmap and Seurat single-cell data integration for ABN talk"
author: "Virginia Howick"
date: "28/02/2021"
output:
  pdf_document: default
  html_document:
    df_print: paged
---

set working directory and load packages. Scater is used to make the single cell experiment object whilst scmap and Seurat will be used for data integration 

Good resource on best R coding practices here: https://style.tidyverse.org/files.html

```{r, message=FALSE}
setwd("/Users/virginiahowick/Documents/abn/")
library(scater, quietly = TRUE)
library(scmap)
library(Seurat)
library(scater)
library(scran)
library(cowplot)
library(gridExtra)
library(viridis)
library(devtools)
```

Read in the data. For today we will be looking at just the IDC (Intra-erythrocytic Developmental Cycle/asexual blood stages) from Pb and Pf. These csvs are the QCed counts and metadata. To quality control Pb cells, we filtered out those with fewer than 230 genes per cell from the filtered expression matrix (generated by cell ranger). For Pf, we used the raw expression matrix from cell ranger and filtered out cells with fewer than 100 genes per cell. Doublets were removed using DoubletFinder.

```{r}

pbcounts <- read.csv("/Users/virginiahowick/Documents/abn/pb10xIDC/pb10xIDC_counts.csv", header=TRUE, row.names = 1)
pbpheno <- read.csv("/Users/virginiahowick/Documents/abn/pb10xIDC/pb10xIDC_pheno.csv", header=TRUE, row.names = 1)

knitr::kable(
  head(pbcounts[ , 1:3]), booktabs = TRUE,
  caption = 'A table of the first 6 rows and 3 columns of the counts table.'
)

knitr::kable(
  head(pbpheno[ , 1:3]), booktabs = TRUE,
  caption = 'A table of the first 6 rows and 3 columns of the pheno table.'
)


pfcounts <- read.csv("/Users/virginiahowick/Documents/abn/pf10xIDC/pf10xIDC_counts.csv", header=TRUE, row.names = 1)
pfpheno <- read.csv("/Users/virginiahowick/Documents/abn/pf10xIDC/pf10xIDC_pheno.csv", header=TRUE, row.names = 1)

knitr::kable(
  head(pfcounts[ , 1:3]), booktabs = TRUE,
  caption = 'A table of the first 6 rows and 3 columns of the counts table.'
)

knitr::kable(
  head(pfpheno[ , 1:3]), booktabs = TRUE,
  caption = 'A table of the first 6 rows and 3 columns of the pheno table.'
)

```

Make both datasets into single cell experiment object
```{r}
pb_sce <- SingleCellExperiment(assays = list(
  counts = as.matrix(pbcounts),
  logcounts = log2(as.matrix(pbcounts) + 1)
), colData = pbpheno)

pb_sce <- runPCA(pb_sce, exprs_values = "logcounts", ntop = 150)
pbpca <- plotPCA(pb_sce, colour_by="stage_pred")
pbpca

pf_sce <- SingleCellExperiment(assays = list(
  counts = as.matrix(pfcounts),
  logcounts = log2(as.matrix(pfcounts) + 1)
), colData = pfpheno)

pf_sce <- runPCA(pf_sce, exprs_values = "logcounts", ntop = 150)
pfpca <- plotPCA(pf_sce, colour_by="bulk")
pfpca
```

Now ortho sce for both datasets

```{r}

#Select one-to-one orthologs
orthos <- read.csv("/Users/virginiahowick/Documents/abn/pbpf_orthos.csv")
orthos <- orthos[orthos$paralog_count == 0, ]
orthos <- orthos[isUnique(orthos$ortho_group) == TRUE, ]

#add the ortho group gene name to the pb sce object
rowData(pb_sce)$ortho_group <- orthos[match(rownames(pb_sce), orthos$pb_id), ]$ortho_group
table(is.na(rowData(pb_sce)$ortho_group))
rowData(pb_sce)$pb_feature_symbol <- rownames(pb_sce)

#rename to orth object and subset ortho genes
pb_sce_orth <- pb_sce
pb_sce_orth <- pb_sce_orth[!is.na(rowData(pb_sce_orth)$ortho_group), ]
rownames(pb_sce_orth) <- rowData(pb_sce_orth)$ortho_group

#DO THE SAME THING WITH PF
#add the ortho group gene name to the pf sce object
rowData(pf_sce)$ortho_group <- orthos[match(rownames(pf_sce), orthos$pf_id), ]$ortho_group
table(is.na(rowData(pf_sce)$ortho_group))
rowData(pf_sce)$pf_feature_symbol <- rownames(pf_sce)

#rename to orth object and subset ortho genes
pf_sce_orth <- pf_sce
pf_sce_orth <- pf_sce_orth[!is.na(rowData(pf_sce_orth)$ortho_group), ]
rownames(pf_sce_orth) <- rowData(pf_sce_orth)$ortho_group

rowData(pf_sce_orth)$feature_symbol <- rownames(pf_sce_orth)
rowData(pb_sce_orth)$feature_symbol <- rownames(pb_sce_orth)
```

```{r}
#build scmap-cell reference index, save this rds
pb_sce_orth <- selectFeatures(pb_sce_orth, suppress_plot = FALSE, n_features = 500)
table(rowData(pb_sce_orth)$scmap_features)

set.seed(1)
pb_sce_orth <- indexCell(pb_sce_orth)

names(metadata(pb_sce_orth)$scmap_cell_index)
length(metadata(pb_sce_orth)$scmap_cell_index$subcentroids)
dim(metadata(pb_sce_orth)$scmap_cell_index$subcentroids[[1]])
metadata(pb_sce_orth)$scmap_cell_index$subcentroids[[1]][,1:5]

```

#run scmap
```{r}
#Project query data set onto cell index
scmapCell_results <- scmapCell(
  pf_sce_orth, 
  list(
    yan = metadata(pb_sce_orth)$scmap_cell_index
  )
)
```

Look into the results
 For each dataset there are two matricies. cells matrix contains the top 10 (scmap default) cell IDs of the cells of the reference dataset that a given cell of the projection dataset is closest to:
   
   Give assignments in two ways:
   1. Take the top cell assignment abs clust, if cosine similarity is less than 0.4 (or adjust if needed) mark as unassigned
 2. For the top 3 nearest neighbors, get a mean of the PCA coordinates and snap to the nearest cell of those coordinates. If any of the top three cells are sim below 0.4 then mark as unassigned.
```{r}

##Top cell assignment method
scmapCell_results$yan$cells[, 1:3]
getcells <- scmapCell_results$yan$cells[1, ]
cdsce <- colData(pb_sce_orth)[getcells, ]
topsim <- scmapCell_results$yan$similarities[1, ]

pf_sce_orth$topcell <- cdsce$sample_id
pf_sce_orth$topcell_ac <- cdsce$absclust
pf_sce_orth$indexPC1 <- cdsce$PC1
pf_sce_orth$indexPC2 <- cdsce$PC2
pf_sce_orth$pbpt <- cdsce$pseudotime
pf_sce_orth$pbbulk <- cdsce$bulk
pf_sce_orth$topcell_sp <- pf_sce_orth$topcell_ac
pf_sce_orth$topsim <- topsim
pf_sce_orth$topcell_sp[pf_sce_orth$topsim < 0.3] <- "unassigned"
table(pf_sce_orth$topcell_sp)


#### TOP 3NN method

#This function makes a list of the PC means for each cell and then do.call below rbinds them into a dataframe called big_data


datalist = list()

for (i in colnames(scmapCell_results$yan$cells)) {
  
  getcellstest <- scmapCell_results$yan$cells[1:3, i]
  cdscetest <- colData(pb_sce_orth)[getcellstest, ]
  PC1mean <- mean(cdscetest$PC1)
  PC2mean <- mean(cdscetest$PC2)
  # ... make some data
  dat <- data.frame(i, PC1mean, PC2mean)
  dat$i <- i  # maybe you want to keep track of which iteration produced it?
  datalist[[i]] <- dat # add it to your list
}

big_data = do.call(rbind, datalist)
# or big_data <- dplyr::bind_rows(datalist)
# or big_data <- data.table::rbindlist(datalist)

test <- big_data[1, ]

df <- data.frame(X=colData(pb_sce_orth)$PC1, Y=colData(pb_sce_orth)$PC2, row.names = rownames(colData(pb_sce_orth)))

#the snap function snaps to the nearest cell in PC coordiantes
snap <- function(df, test){
  require(Biobase)
  d <- matchpt(as.matrix(df),
               as.matrix(data.frame(X=test$PC1mean,Y=test$PC2mean)))
  
  min_row <- rownames(d[d$distance==min(d$distance),])
  
  test$X_snap <- unique(df[min_row,"X"])
  test$Y_snap <- unique(df[min_row,"Y"])
  test$pb_cell <- min_row
  
  test
}

#this loops through each cell and in big_data and runs the snap function
datalist2 = list()
colnames(big_data) <- c("sample_id", "PC1mean", "PC2mean")
for (i in rownames(big_data)) {
  test <- big_data[i, ]
  coord <- snap(df, test)
  coord$i <- i
  datalist2[[i]] <- coord
}
big_data2 = do.call(rbind, datalist2)


table(rownames(big_data2)==rownames(colData(pf_sce_orth)))

allpbcd <- colData(pb_sce_orth)
allpbcd <- as.data.frame(allpbcd)
pbabsclust <- allpbcd[, c("absclust", "clock_pseudotime"), drop=FALSE]
pbabsclust$pb_sample_id <- rownames(pbabsclust)

# Now merge the pc cell asignments with their abs clust and get in the right order
big_data3 <- merge(big_data2, pbabsclust, by.x = "pb_cell", by.y = "pb_sample_id", all.x=TRUE, all.y=FALSE)
big_data4 <- big_data3[match(rownames(big_data2), big_data3$sample_id), ]


colors <- c("6"="#78C679",
            "2"="#D1EC9F",
            "0"="#FEB24C",
            "1"="#F4CF63",
            "3"="#FEEEAA",
            "4"="#85B1D3",
            "7"="#9ecae1",
            "5"="#C9E8F1",
            "M"= "#B7B7D8",
            "F"="#9C96C6",
            "unassigned"="black")


ggplot(big_data4, aes(PC1mean, PC2mean)) + geom_point(aes(colour=factor(big_data4$absclust))) + scale_color_manual(values = colors) 

ggplot(big_data4, aes(X_snap, Y_snap)) + geom_point(aes(colour=factor(big_data4$absclust))) + scale_color_manual(values = colors) 

##add info to SCE and save colData, to be an assigned cell all 3NN must have a cos sim >0.4
scmapCell_results$yan$similarities[, 1:3]
topsim1 <- scmapCell_results$yan$similarities[1, ]
topsim2 <- scmapCell_results$yan$similarities[2, ]
topsim3 <- scmapCell_results$yan$similarities[3, ]

table(big_data4$sample_id==rownames(colData(pf_sce_orth)))
#pf_sce_orth$pb_cell <- big_data4$pb_cell
#pf_sce_orth$PC1mean <- big_data4$PC1mean
bd4 <- big_data4[, c("pb_cell", "sample_id", "PC1mean", "PC2mean", "X_snap", "Y_snap", "absclust", "clock_pseudotime" )]

colData(pf_sce_orth) <- cbind(colData(pf_sce_orth), bd4)

pf_sce_orth$topsim1 <- topsim1
pf_sce_orth$topsim2 <- topsim2
pf_sce_orth$topsim3 <- topsim3
pf_sce_orth$stage_pred <- pf_sce_orth$absclust
pf_sce_orth$stage_pred[pf_sce_orth$topsim1 < 0.3 | pf_sce_orth$topsim2 < 0.3 | pf_sce_orth$topsim3 < 0.3] <- "unassigned"
table(pf_sce_orth$stage_pred)

#write.csv(bd4, "pfcellassignmentswithmean3nn_20181029.csv")
#write.csv(colData(pf_sce_orth), "pf3d7100scmapclusts2methodindexn100_20190107.csv")

```


```{r}
pbcounts <- as.data.frame(counts(pb_sce_orth))
pfcounts <- as.data.frame(counts(pf_sce_orth))

pbcd <- as.data.frame(colData(pb_sce_orth))
pfcd <- as.data.frame(colData(pf_sce_orth))

pb_seurat_orth <- CreateSeuratObject(pbcounts, assay = "RNA", meta.data = pbcd)
pf_seurat_orth <- CreateSeuratObject(pfcounts, assay = "RNA", meta.data = pfcd)


pb_seurat_orth$species <- rep("Pb", length(pb_seurat_orth$nGene))
pf_seurat_orth$species <- rep("Pf", length(pf_seurat_orth$nGene))

Idents(pb_seurat_orth) <- "stage_pred"
pb_seurat_orth <- FindVariableFeatures(pb_seurat_orth, selection.method = "vst", nfeatures = 500)
pf_seurat_orth <- FindVariableFeatures(pf_seurat_orth, selection.method = "vst", nfeatures = 500)
```


##Perform integration
We then identify anchors using the FindIntegrationAnchors function, which takes a list of Seurat objects as input, and use these anchors to integrate the two datasets together with IntegrateData.
```{r, tidy=TRUE}
p_anchors <- FindIntegrationAnchors(object.list = list(pb_seurat_orth, pf_seurat_orth), dims = 1:20)
p_combined <- IntegrateData(anchorset = p_anchors, dims = 1:20)
```

##Perform an integrated analysis
Now we can run a single integrated analysis on all cells!
```{r, tidy=TRUE}
DefaultAssay(p_combined) <- "integrated"

# Run the standard workflow for visualization and clustering
p_combined <- ScaleData(p_combined, verbose = FALSE)
p_combined <- RunPCA(p_combined, npcs = 30, verbose = FALSE)
# t-SNE and Clustering
#p.combined <- FindVariableFeatures(p.combined, selection.method = "vst", nfeatures = 500)
#hvg <- HVFInfo(object = p.combined)
#hvgfeat <- rownames(hvg)
p_combined <- RunUMAP(p_combined,  reduction = "pca", dims = 1:20, umap.method = "uwot", n.neighbors = 10, min.dist = 0.3, spread = 1, seed.use=222)
p <- DimPlot(p_combined, reduction = "umap", group.by = "species")
pdat <- p$data

colors = c(Pf = "#3399FF", Pb = "#FF9933")

ggplot(pdat, aes(UMAP_1, UMAP_2)) + geom_point(aes(colour = species), size=0.8) + theme_bw() + 
    scale_colour_manual(values = colors) +
  theme(axis.text = element_blank(), 
    axis.ticks = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
    axis.title = element_text(size = 10), legend.position = "none")

p_combined <- FindNeighbors(p_combined, reduction = "pca", dims = 1:20)
p_combined <- FindClusters(p_combined, resolution = 0.3)



p1 <- DimPlot(p_combined, reduction = "umap", group.by = "species")
p2 <- DimPlot(p_combined, reduction = "umap", label = TRUE)
plot_grid(p1, p2)

DimPlot(p_combined, reduction = "umap", group.by = "stage_pred")

```

```{r}
session_info()
```

